-----
### 컨테이너의 상태 (State)
-----
<div align="center">
<img src="https://github.com/user-attachments/assets/08e5aa74-09de-4af1-8773-f09387a750cf">
</div>

1. 컨테이너는 기본적으로 상태 없음(Statless)의 성격을 가짐
   - 이미지는 읽기 전용 레이어이며, 이미지를 컨테이너로 실행시키면 읽기 / 쓰기 레이어인 컨테이너 레이어가 추가
   - 컨테이너가 실행된 후 발생하는 모든 변경 사항은 컨테이너 레이어에만 쌓이게 되며, 컨테이너가 종료되면 변경 사항이 모두 사라짐
   - 컨테이너 2가 종료되는 순간, 컨테이너 2의 컨테이너 레이어에서 쌓여왔던 모든 내용이 삭제
   - 컨테이너 1을 실행 중인 상태에서 이 컨테이너 이미지의 버전을 변경할 때도 실행 중인 컨테이널르 삭제하고 새로운 이미지를 실행시켜야 함
   - 즉, 컨테이너는 실행할 때 한 번 지정한 이미지는 변경 불가
   - 변경 사항이 적용되어 있는 새로운 이미지를 통해 새로운 버전의 컨테이너를 실행해야 함
   - 이처럼, 상태를 가지지 않는 것은 컨테이너의 중요 특징 중 하나이며, 상태를 가진다는 것은 개수가 많아질 수록, 하나하나의 경우의 수가 늘어나는 것을 의미하므로, 따로 관리해줘야 함
   - 컨테이너는 Stateless하기 때문네 빠르고 쉽게 개수를 증가시킬 수 있고, 운영 중인 서버 환경은 자주 변경될 수 있으며, 다른 환경에서도 빠르게 배포 가능

<div align="center">
<img src="https://github.com/user-attachments/assets/7ab58508-adce-4e6b-882e-bc75540f58fd">
<img src="https://github.com/user-attachments/assets/969ad1f2-439d-4780-b136-3fa269ba6f45">
</div>

   - 예를 들어, Nginx 웹 서버의 경우 Nginx 서버 설정이 변경 또는 버전 업그레이드되는 경우 존재 또는 새로운 버전 소스 코드를 배포해야 되는 경우 필요
     + 전통적 방식 : 실행 중인 서버에 직접 변경 사항 업데이트 (서버에 접근 후, 기존 애플리케이션 중지시키고 새로운 버전의 애플리케이션으로 덮어쓰기한 다음 다시 애플리케이션 실행)
       * 동일한 서버가 10대 있으면, 모두 같은 변경사항을 적용
       * 이런 것은 서버 한 대마다 유일한 상태를 가짐을 의미
       * 이 방식에서 변경사항을 적용한 서버 10대가 모두 동일한 상태라는 것을 보장하기 어려움
       * 실제 소프트웨어가 실행 중인 서버에서 변경사항을 적용해야하므로 장애로도 이어질 수 있으므로, 변경사항 적용이 어려워짐
       * 따라서, 소프트웨어 업데이트 주기가 늦어짐

     + 하지만 컨테이너는 이미지라는 템플릿 기반으로 동작하므로 기존과 다른 방식으로 작동
       * 컨테이너 자체는 상태를 가지지 않고, 모든 상태는 이미지에 기록
       * 애플리케이션의 소스나 라이브러리 버전이 업데이트 되는 것과 같은 변경 사항은 모두 새로운 버전의 이미지로 만들어야 함
       * Nginx의 버전 업그레이드 예시도 실행 중 컨테이너에 접근해 업그레이드를 하는 것이 아니라 아예 새로운 버전의 이미지를 만들어서 배포
       * 먼저, 실행 중이던 이전 버전 컨테이너는 제거
       * 컨테이너는 Stateless하기 때문에 빠르고 쉽게 개수를 증가시킬 수 있음
       * 다른 환경에서도 애플리케이션을 바로 실행할 수 있는 시작점 상태 이미지만 있으면 배포 가능
       * 애플리케이션 실행에 필요한 것은 모두 이미지에 저장, 이 이미지에 컨테이너 레이어만 추가하면 바로 컨테이너를 실행시킬 수 있으므로 컨테이너 개수가 늘어나는 것이 작은 공간만 차지
       * 따라서, 컨테이너를 실행하는 속도도 빨라짐

   + 이처럼 컨테이너는 상태가 없어서 빠르고 쉽게 개수를 증가시킬 수 있으므로 트래픽이 갑자기 증가해도 더 유연하게 대처 가능

<div align="center">
<img src="https://github.com/user-attachments/assets/a695568e-3c62-4428-8fb1-e4ea9e6ab00c">
</div>

2. 클라우드 네이티브 구조에서 서버를 다루는 방법론 : Pet & Cattle
   - 클라우드 네이티브 환경에서는 MSA 아키텍쳐로 개발이 이루어지며, 아키텍쳐 구조 상 서버의 개수가 아주 많아지므로, 서버를 바라보는 관점도 변화
   - Pet & Cattle 방식은 서버를 바라보는 관점의 변화
     + Pet : 전통적인 서버 방법론으로, 서버 한대를 중요하게 생각하는 것으로 서버를 한 대 한 대 직접 관리 (가정에서 키우는 애완동물 생각)
       * 서버에 문제가 생기거나 서버가 종료되는 것은 서비스의 장애라고 여겨지며, 항상 서버의 상태를 주시하고 서버를 관리
       * 따라서, 가상 머신에 적합
       * 서버는 고유한 이름을 가짐
       * 서버에 장애가 발생하면 문제를 서버 내부에서 해결 또는 백업을 사용해 복구 시도
       * 서버의 상태(OS나 라이브러리 버전, 실행 중인 소프트웨어 버전 등)가 내부에 저장
       * 버전이 변경되거나 패치가 발생하면, 이 변경사항들을 적용하고 관리하므로 버전 불일치가 발생할 가능성이 커짐
     + Cattle : 컨테이너를 활용한 서버 방법론 (목장에서 관리하는 가축 생각)
       * 서버를 일종의 소모품이라고 생각하여, 서버가 에러가 발생하거나 서버가 갑자기 종료되는 것은 충분히 발생가능한 것
       * 따라서, 서버가 종료되면 새로운 서버를 빠르게 실행시켜 기존 서버 대체
       * 이처럼 빠르게 서버를 늘리거나 기존 서버를 새 서버를 대체하려면 서버가 Stateless해야 함
       * 컨테이너에 잘 어울리는 방식
       * 컨테이너에 랜덤한 일련번호 부여한 이름 생성
       * 문제가 발생한 서버를 제거한 다음 이 서버를 대체할 서버를 바로 실행
       * 상태가 없고, 상태를 유지할 데이터가 있으면 외부 마운트를 통해 데이터를 저장
      
   - 즉, 상태를 가지고 있는 펫 방식에서는 서버를 교체하기가 매우 어려우며, 이 서버에 그동안 히스토리가 모두 쌓여있으며, 모놀리식 구조, OnPromise에 많이 사용
   - 캐슬 방식에는 컨테이너에 상태가 없으므로 컨테이너를 쉽게 교체 가능하며, 변경이 필요한 경우 변경사항을 적용한 새로운 이미지로 대체 가능하며, MSA, WEBAPP 구조에 주로 사용되는 방식

3. 실습 - 컨테이너의 Stateless 한 속성 확인
   - 컨테이너를 실행한 다음 컨테이너 안에서 파일 변경 후, 컨테이너를 다시 시작해 변경 부분이 남아있는지 테스트
   - easydocker 폴더에서 mkdir index && cd index
   - echo Hello Volume! > index.html : index.html 파일 생성 후, cat index.html
```
young@DESKTOP-7IP75SV MINGW64 ~/OneDrive/Desktop/easydocker/index
$ echo Hello Volume! > index.html

young@DESKTOP-7IP75SV MINGW64 ~/OneDrive/Desktop/easydocker/index
$ cat index.html
Hello Volume!
```

  - ls 목록으로 파일 목록 확인

  - Nginx 컨테이너 실행 : docker run -d --name my-nginx nginx
  - 컨테이너로 파일 복사 : docker cp index.html my-nginx:usr/share/nginx/html/index.html
  - Nginx 컨테이너 삭제 : docker rm -f my-nginx
  - 새로운 Nginx 컨테이너 실행 : 다시 한 번, docker run -d --name my-nginx nginx 실행
  - 새로운 컨테이너에서 index.html 파일 추출 : docker cp my-nginx:usr/share/nginx/html/index.html indexfromcontainer.html
  - ls로 목록 확인
  - cat indexfromcontainer.html
  - 결과 : 컨테이너로 복사한 index 파일이 아닌 이미지의 index.html 파일 추출
```
young@DESKTOP-7IP75SV MINGW64 ~/OneDrive/Desktop/easydocker/index
$ cat indexfromcontainer.html
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
html { color-scheme: light dark; }
body { width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
```
  - 컨테이너를 삭제한 시점에서는 컨테이너가 가진 컨테이너 레이어의 모든 내용은 삭제되므로, 다시 컨테이너를 실행하면 기존에 가지고 있는 Nginx 이미지 위에 새로운 읽기 / 쓰기 레이어인 컨테이너 레이어가 추가되므로 복사한 내용은 남아있지 않음
  - 이처럼 컨테이너는 Statless 하므로 컨테이너가 삭제된다는 것은 그동안 컨테이너가 가지고 있었던 모든 변경사항을 잃어버린다는 것
  - 즉, 이 컨테이너를 실행한다는 것은 이미지에 저장돼있는 상태 그댈오 출발한다는 것을 의미

  - docker rm -f my-nginx
  - cd .. 이후, rm -rf index

4. 컨테이너의 Statless 특징
   - 컨테이너 이미지는 한 번 지정된 이후 변경되지 않음 : 불변성(Immutability)
     + 따라서, 새로운 버전의 컨테이너가 필요할 때는 이 컨테이너를 실행할 새로운 이미지를 만들어야 함

   - 컨테이너는 언제든지 새로운 컨테이너로 대체될 수 있음
     + 컨테이너는 이미지 기반으로 실행되고, 실제 실행되기를 원하는 서버의 상태는 이미지에 저장되므로 컨테이너를 종료하고 실행하는 것이 자유로워짐
     + 특정 컨테이너에 쌓인 파일들이 이 컨테이너 동작에 영향을 주지 않으므로 문제가 발생해서 서버를 지우고 다시 생성하거나 필요하지 않은 서버를 제거할 때 걱정 없이 제거 가능

   - 컨테이너는 어떤 호스트에서든 컨테이너 실행 가능
     + 호스트라는 것은 배포되는 환경을 지칭
     + 즉, 이미지만 있으면 환경 제약 없이 컨테이너를 실행할 수 있음

   - 컨테이너는 동일한 역할을 하는 컨테이너를 여러 개 만들 수 있으며, 트래픽에 유연하게 대처 가능
     + 늘어나는 트래픽에 대해 더 유연하게 대응 가능

   - 장애가 발생한 경우에도 문제가 발생한 컨테이너를 삭제하고, 새로운 컨테이너를 빠르게 시작 가능

5. 컨테이너의 Stateless 제약
   - 컨테이너는 상태가 없으므로 데이터를 영구적으로 저장하기 위해서는 별도의 데이터베이스 서버 사용이 필수적
     + 컨테이너 자체만으로는 상태가 없으므로 저장하거나 공유가 필요한 데이터는 무조건 외부에 저장해야 함
    
   - 사용자의 세션 정보나 캐시 같은 정보도 외부에 저장해야 함
     + 예) 사용자의 세션 정보 : 사용자의 로그인 정보나 장바구니에 넣어놓은 상품 리스트 등
     + 이런 정보는 임시로 저장해야되는 정보로, 주로 캐시 서버나 사용자의 브라우저에 저장되는 쿠키를 통해 관리될 수 있음

   - 동일한 요청에 항상 동일한 결과를 제공해야 함
     + 서버를 여러 대 실행해놓았을 때 각 서버마다 다른 응답을 제공하면 안 됨
     + 이유는 이런 서버들은 트래픽이 증가함에 따라 여러 대로 실행시킬 수 있어야 하고, 여러 개로 실행된 애플리케이션의 서버들이 동일한 요청에 대해 다른 응답을 제공할 경우, Statless한 속성을 애플리케이션에서 해치고 있다고 볼 수 있음

   - 환경 변수나 구성 파일을 사용해 설정을 외부에서 주입헐을 수 있어야 함
     + 컨테이너 자체로는 상태를 가질 수 없지만, 이 이미지를 컨테이너로 실행할 때 어떤 CMD 값을 주고 어떤 환경 변수를 주입하냐에 따라 완전히 다른 애플리케이션 서버 구성 가능
     + 이미지는 하나로 유지하면서, 다양한 환경에서 이미지를 컨테이너로 활용 가능
