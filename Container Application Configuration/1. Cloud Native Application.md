-----
### 클라우드 네이티브 애플리케이션 (Cloud Native Application)
-----
<div align="center">
<img src="https://github.com/user-attachments/assets/7c736335-f4af-4486-aef9-4f77dfdaebb6">
</div>

1. 클라우드 (Cloud) : 스토리지 저장소를 의미
   - 하나의 물리 드라이브에 여러 사용자의 파일이 저장될 수 있는 것
   - 클라우드 서비스를 이용한다는 것은 인프라적인 부분은 신경쓰지 않고 실제 서비스의 기능만 사용
   - 쉽게 말하자면, 다른 회사의 서버를 빌려서 운영하는 것 (예) 마이크로소프트의 Azure, 아마존의 AWS, 구글의 GCP 등)

2. 클라우드 컴퓨팅 : 단순히 스토리지에 국한되지 않고, 전반적인 서버 컴퓨터로 개념이 확장
   - 예) 2코어의 4GB 메모리를 가진 컴퓨터를 사용하고 싶다면, 클라우드 사업자 계정을 만들어 서버를 구매하면 서버에 접속 가능
   - 클라우드 사업자는 대형 데이터 센터를 지역별로 구축해놓고 가상화 기술 활용
   - 즉, 서버를 구매할 때마다 VM을 하나 제공하여 접속 정보를 제공해주는 것

3. Public Cloud : 누구나 사용할 수 있는 클라우드 서비스 (다른 회사가 모두에게 서버를 빌려줄 경우)
4. Private Cluod : 같은 조직 내 속해 있는 회사에만 서버를 만들어서 제공 (보안이 뛰어나고 비용적으로 효율적임) (다른 회사가 특정 조직에게만 서버를 빌려줄 경우)
5. 클라우드의 특징 : 사용 요청을 한 즉시 서버를 만들어줌 (프로비저닝(Provisioning) : 서버를 만드는 것)
   - 클라우드는 서버를 사용한 시간을 측정해 시간이나 월 단위로 요금이 청구됨
  
6. 클라우드는 현대 애플리케이션이 겪는 다양한 문제들을 클라우드 환경 구성을 통해 해결
   - 트래픽이 증가할 때 빠르게 대처할 수 있는가? (확장성, Scalability)
     + 클라우드는 트래픽이 증가할 때 빠르게 대처할 수 있음
       * 클라우드 환경에서는 서버 추가가 10분 내로 이루어지며, OnPromise에서는 서버가 미리 준비되지 않으면 새로운 서버 증가에 오랜 시간이 소요 (주문, 배송, 설치)
     + 현대 애플리케이션은 사용자의 수요 변동이 큼 (예) 온라인 커머스의 경우, 특정 할인 기간에 사용자의 요청이 급증 가능 / 회계 시스템의 경우 특정 기간이 아니면 트래픽이 없음)
     + 트래픽 변동에 유연하게 대처가 가능 (트래픽이 증가할 때는 빠르세 서버 증설 가능, 트래픽이 없을 땐 서버 줄일 수 있음)
     + 보통 서버를 사내에 직접 구성하면 서버 용량 증설이 쉽지 않음 (트래픽의 최댓값을 예상한 다음, 이 최대치에 맞춰 서버 구성했기 때문임)
     + 따라서, 서버가 수용할 수 있는 양 이상의 트래픽을 받으면 서버가 다운될 수 있음
     + 클라우드를 사용하면 서버 추가가 빠르게 이루어짐
     + 따라서, 불필요한 서버 사용은 줄이고, 사용한 만큼 비용을 지불 가능 : 확장성 (Scalability)
     + 클라우드를 사용하면 확장성을 가질 수 있고, 트래픽 증가에 빠르게 대처 가능

   - 장애가 발생했을 때 빠르게 대처하여 복구할 수 있는가? (복원력, Resilience)
     + 회사 내 서버실에서 모든 서비스를 운영하고 있는 상태에서 갑자기 정전 발생
     + 모든 서비스에 장애가 일어나고 심한 경우 데이터가 사라지는 문제 발생 가능
     + 하지만, 클라우드 서비스는 복원력이 뛰어남 : 이는 전 세계의 다수의 데이터 센터를 가지고 있기 때문임
     + 즉, 서울의 데이터 센터에 장애가 발생하더라도 타 지역의 데이터 센터의 서버로 트래픽 전환 가능
     + 이렇게 복구에 사용하는 서버 : DR (Disaster Recovery) - 클라우드 환경에서는 백업 및 복구가 빠르게 이루어질 수 있으며, 장애에 대응하기 위한 다양한 지역의 서버 구축 가능
       
   - 운영 비용을 효율적으로 운영할 수 있는가?
     + 클라우드를 사용하면 글로벌 다양한 지역의 서버를 저렴한 비용을 가질 수 있으며, 운영 비용에 더 효율적
     + 국내 업체가 해외 데이터 센터를 구축하려면 비용이 많이 발생
     + 클라우드를 사용하면 이런 서버들을 해외 서비스 전용 서버로 사용 가능, 재해복구용 서버로 활용 가능
     + 비효율적으로 사용하게 되면 비용이 훨씬 비싸게 청구될 수 있음
      + 전문 아키텍터가 서버 가용량을 적절히 구성해야 하고, 비용 최적화를 지속적으로 수행해야함
      + 그리고 단순히 해외 서버를 구성한다고 해서 재해복구나 해외 서비스가 바로 이루어지는 것이 아님

7. 핵심은 클라우드가 아닌 애플리케이션에 있음
    - 애플리케이션이 클라우드에 적합하지 않으면 클라우드를 사용하는 것은 크게 의미가 없을 수 있음
    - 클라우드 : 복잡한 대형 애플리케이션이 겪는 다양한 문제들을 클라우드 환경 구성을 통해 해결
    - 💡 클라우드 네이티브 (Cloud Native) 애플리케이션 : 클라우드 환경을 더 잘 활용할 수 있는 애플리케이션 구조를 의미

8. 클라우드 네이티브 애플리케이션
    - MSA : 애플리케이션을 여러 단위로 분리해서 트래픽 증가에 효율적으로 대처하기 위한 소프트웨어 아키텍쳐로, 트래픽 증가에 빠르게 대처하기 위해 애플리케이션이 MSA 구조로 개발되어야 함

    - 컨테이너 (Container) : 컨테이너 이미지에는 소프트웨어가 실행하기 위한 환경이 모두 포함하므로 컨테이너를 활용해 동작이 보장되어야함
      + 이 이미지를 가지고 있으면 어떤 환경에서든 동일한 실행 동작 보장 가능
      + 컨테이너를 사용하지 않으면 각 서버의 프로그램을 별도로 운영해야 하고, 결국 환경 불일치 문제 발생 가능성이 커짐

    - 상태 비저장 (Statelss)
      + 애플리케이션 자체는 상태를 가지지 않아야 하며, 상태를 가질 경우 외부의 이 상태가 분리되어야 함
      + 상태를 가진다는 것 : 각 서버가 결국 다르게 동작하는 것
      + 상태를 가지지 않아야 언제 어디서나 빠르게 배포될 수 있고 여러 대 서버가 동시에 같은 역할로 운영 가능
      + 컨테이너는 태생적으로 상태 비저장 특징을 가짐 (이미지로 컨테이너로 실행하면 컨테이너에 읽기 / 쓰기 레이어가 만들어지는데, 컨테이너를 삭제하면 읽기 / 쓰기 레이어도 함께 삭제)
      + 컨테이너를 사용한다는 것 : Stateless한 상태 비저장 형태로 운영한다는 것

   - DevOps 및 CI/CD : 배포가 자동화되어야 하고 빠르게 릴리즈가 수행되어야 함
   - 12Factors : 클라우드 환경에서 운영하는 애플리케이션 요구사항에 대해 정리 (```https://12factor.net/ko/```)

9. 마이크로 서비스 아키텍쳐 (Micro Service Architecture, MSA)
<div align="center">
<img src="https://github.com/user-attachments/assets/9df109c1-27ef-423d-860f-7760921ac4a9">
</div>


   - 모놀리식 방식 : 애플리케이션을 개발할 때, 모든 기능을 하나의 애플리케이션에 구성하는 전통적인 방식
      + 하나의 애플리케이션 크기가 커지므로, 애플리케이션 실행 시간이 오래 걸림
      + 트래픽이 증가할 때는 이 트래픽을 받을 수 있는 새로운 서버가 증가되어야 하는데, 서버의 실행 시간이 길어지면 트래픽에 대처할 수 있는 능력도 떨어짐
      + 또한, 빌드 시간이나 배포 시간도 오래 걸림
      + 또한, 실제 트래픽을 사용하지 않는 다른 기능도 포함되므로 서버를 하나 늘릴 때 마다 비효율적으로 리소스 사용

   - MSA : 도메인이나 기능별로 여러 개의 모듈로 분리해서 서버를 배포
      + 서버들은 각 트래픽을 수용
      + 주문 트래픽이 늘어나면 주문 기능을 가진 모듈만 증가
      + 각 모듈의 크기가 작아졌으므로 간편해지고 서버를 Scale-Out하는 시간도 상승 (서버를 Scale-Out : 서버의 대수를 늘려서 트래픽에 대처하는 것을 의미 / Scale-In : 서버의 개수를 줄임)
      + 모듈별로 완전히 독립되었으므로 각 모듈들이 다른 언어를 사용해 개발 가능
      + 서비스에 기능 장애가 발생해도 모듈 단위로 발생하므로 하나의 기능 에러로 인해 모든 서비스에 영향을 미치지 않음

  - 모놀리식 방식과 MSA 방식의 장단점
<div align="center">
<img src="https://github.com/user-attachments/assets/3848a0fb-837f-4d29-ad3f-18f03568ffd9">
</div>

  - 모놀리식 방식
      + 단일 코드 베이스, 단일 애플리케이션으로 개발
      + 한 번 배포할 때 코드를 다시 배포
      + 서버를 여러 대 두는 것은 비효율적이므로 보통 서버 한대의 리소스를 증가시키는 수직 확장(Scale-Up) 방식 사용
      + 상대적으로 낮은 개발 난이도로 초반에는 개발 속도가 빠름 (하지만, 프로젝트가 커질수록 전반적 파악이 어려워지고 개발 속도가 느려짐)
      + 장애가 발생하면 전체 애플리케이션이 영향을 받음
      + 하나의 스택을 채용해서 개발이 이루어짐
      + 유지보수에 있어 전체 소스코드가 유기적으로 연결되어 있으므로 전반적인 소스코드 이해 필요하며, 전체 모듈을 이해하는데 오랜 시간이 걸림

  - MSA
      + 기능별로 독립된 여러 개 서비스가 존재
      + 변경된 모듈만 따로 배포
      + 서버의 대수를 늘리는 수평 확장(Scale-Out) 방식 사용
      + 초기 구성 시간이 오래걸리고 아키텍쳐가 복잡해진다는 단점
      + 문제가 발생한 기능만 장애가 발생
      + 서비스 별로 다양한 기술 스택 활용 가능
      + 서비스가 독립적으로 동작하는 것이 보장되어있으므로, 하나의 서비스에 대한 부분만 파악하면 됨
      + 하지만, 서버 개수가 늘어나므로 전반적 리소스 사용량이 늘어나고, 하나의 애플리케이션만 있는 것보다 모든 서버들이 직접 통신을 해야하므로 네트워크 통신 관리 및 각 서버들의 데이터 일관성 이슈도 관리 필요 (즉, 복잡도가 매우 높음)
     
    - 정리하자면, MSA는 클라우드 네이티브 애플리케이션에 잘 어울리는 소프트웨어 구조이며, MSA 아키텍쳐 장점을 잘 활용하기 위해서는 컨테이너 활용이 필수
    
